<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OtakuDex</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    /* CRITICAL FIX: Ensure the absolute root HTML and Body elements are dark */
    html, body {
        background-color: #0d0d0d; /* Matching the dark-bg custom color */
    }

    /* Custom configuration for Tailwind colors and font */
    :root {
      --accent-color: #a855f7; /* Purple-500 */
      --secondary-text: #b3b3b3;
    }
    
    /* Tailwind Configuration */
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'dark-bg': '#0d0d0d', /* Primary Dark background */
            'card-dark': '#1a1a1a', /* Sidebar and List Card background */
            'modal-bg': '#262626', /* NEW: Slightly lighter background for the modal content */
            'border-dark': '#333333', /* Border color */
          },
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
          }
        }
      }
    }

    /* CUSTOM CSS FOR ANIMATIONS (Tailwind doesn't cover @keyframes) */
    .loading-spinner {
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top: 4px solid var(--accent-color);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        margin-right: 0.5rem;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    /* Utility class for image placeholder in episode card */
    .episode-template-img {
        width: 80px; 
        height: 100%;
        min-width: 80px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 0.8rem;
        font-weight: 700;
        background-color: #2b2b2b; /* Darker background for image area */
        color: var(--secondary-text);
        padding: 0.5rem;
    }
  </style>
</head>
<!-- The body also explicitly uses the dark-bg class -->
<body class="font-sans bg-dark-bg text-white flex flex-col h-screen overflow-hidden">
  
  <!-- Header/Toolbar -->
  <header class="header p-4 bg-black shadow-2xl border-b border-purple-600 flex justify-between items-center flex-shrink-0 z-10">
    <div class="header-title text-2xl font-extrabold text-purple-500 tracking-wider">OtakuDex</div>
    <button id="settings-button" class="action-button bg-purple-600 hover:bg-purple-500 text-white py-2 px-4 rounded-lg font-semibold cursor-pointer shadow-lg transition duration-200 flex items-center gap-2">
      <i class="fa-solid fa-gear text-xl"></i> Settings
    </button>
  </header>

  <div class="content-area flex-grow flex overflow-hidden">
    
    <!-- Sidebar -->
    <div id="sidebar" class="sidebar w-72 bg-card-dark p-0 overflow-y-auto border-r border-border-dark flex-shrink-0 shadow-lg">
        <div id="show-list-title" class="sidebar-title px-6 pt-4 pb-3 text-lg font-bold text-gray-400 border-b border-border-dark mb-4 hidden">TV Shows</div>
        <!-- Show list injected here -->
    </div>
    
    <!-- Detail View - ENSURED it uses the dark-bg class -->
    <div id="detail-view" class="detail-view flex-grow p-10 overflow-y-auto bg-dark-bg">
        <div id="initial-state-message">
            <h2 class="text-purple-500 text-3xl font-bold mb-4">Welcome to OtakuDex!</h2>
            <p class="text-xl text-gray-400">Open **Settings** (gear icon) to scan your library and begin cataloging your media.</p>
        </div>
        
        <!-- Detailed content for selected show injected here -->
    </div>

  </div>
  
  <!-- Status Bar -->
  <div id="status-container" class="status-message p-3 bg-black text-gray-400 text-center text-sm flex-shrink-0 border-t border-border-dark">
      <div class="scan-status-container flex items-center justify-center min-h-[40px]">
          <!-- Status messages and spinner injected here -->
      </div>
  </div>

  <!-- SETTINGS MODAL -->
  <div id="settings-modal" 
       class="modal-overlay hidden fixed inset-0 bg-black bg-opacity-80 z-[1000] flex justify-center items-center opacity-0 transition-opacity duration-300">
    <!-- Updated class to use bg-modal-bg and a stronger shadow -->
    <div class="modal-content bg-modal-bg rounded-xl w-11/12 max-w-3xl max-h-[90vh] overflow-y-auto p-8 shadow-2xl shadow-purple-900/50 transform scale-90 transition-transform duration-300">
        <div class="modal-header flex justify-between items-center border-b-2 border-border-dark pb-4 mb-6">
            <h2 class="m-0 text-purple-500 text-2xl font-bold">Application Settings</h2>
            <button id="close-settings-button" class="text-gray-400 hover:text-white text-4xl cursor-pointer p-2 leading-none">&times;</button>
        </div>
        
        <div class="settings-section mb-8 pt-4 border-t border-border-dark first:border-t-0 first:pt-0">
            <h3 class="text-xl text-white font-semibold mb-3">Library Management</h3>
            <p class="text-gray-400 text-sm mb-4">Use this option to select the root folder containing your media files. Scanning may take time.</p>
            <div class="flex items-center gap-4">
                <button id="settings-scan-button" class="action-button bg-purple-600 hover:bg-purple-500 text-white py-2 px-4 rounded-lg font-semibold cursor-pointer shadow-md transition duration-200 flex items-center gap-2">
                    <i class="fa-solid fa-folder-open"></i> Scan Library
                </button>
            </div>
        </div>
        
        <div class="settings-section mb-8 pt-4 border-t border-border-dark">
            <h3 class="text-xl text-white font-semibold mb-3">Metadata Configuration (WIP)</h3>
            <p class="text-gray-400 text-sm mb-4">Select your preferred sources for retrieving show titles, descriptions, and episode information. </p>

            <!-- Primary Provider -->
            <label class="setting-label block font-semibold mt-4 mb-2 text-gray-400">Primary Metadata Provider:</label>
            <div id="primary-provider-group" class="provider-group flex gap-4 flex-wrap">
                <!-- Radio buttons injected by JS -->
            </div>

            <!-- Secondary/Backup Provider -->
            <label class="setting-label block font-semibold mt-4 mb-2 text-gray-400">Backup Metadata Provider:</label>
            <p class="text-xs text-gray-500 mb-2">Used if the primary provider fails to find a match or is unreachable.</p>
            <div id="secondary-provider-group" class="provider-group flex gap-4 flex-wrap">
                <!-- Radio buttons injected by JS -->
            </div>
        </div>
    </div>
  </div>

  <script>
    // --- MOCK IPC BRIDGE FOR WEB ENVIRONMENT (Fix for window.api is undefined) ---
    // This section simulates the native functions (like file picking and scanning) 
    // that would normally be provided by an Electron preload script.
    if (typeof window.api === 'undefined') {
        const mockShows = [
            {
                id: 'show-a',
                title: 'Mock Anime Title A',
                rootPath: '/Users/mock/Anime/Mock_Anime_Title_A',
                seasons: [
                    {
                        title: 'Season 1',
                        episodes: [
                            { fullPath: '/Users/mock/Anime/A/S1E1.mkv' },
                            { fullPath: '/Users/mock/Anime/A/S1E2.mkv' },
                            { fullPath: '/Users/mock/Anime/A/S1E3.mkv' },
                        ]
                    },
                    {
                        title: 'OVA/Extras',
                        episodes: [
                            { fullPath: '/Users/mock/Anime/A/OVA1.mkv' },
                        ]
                    }
                ]
            },
            {
                id: 'show-b',
                title: 'Cool Manga Adaptation B',
                rootPath: '/Users/mock/Anime/Cool_Manga_Adaptation_B',
                seasons: [
                    {
                        title: 'Season 1',
                        episodes: [
                            { fullPath: '/Users/mock/Anime/B/S1E1.mp4' },
                            { fullPath: '/Users/mock/Anime/B/S1E2.mp4' },
                        ]
                    }
                ]
            }
        ];

        window.api = {
            // Mock: Returns cached data immediately 
            fetchLibraryCache: () => Promise.resolve({
                success: true,
                message: "Loaded mock data from cache.",
                shows: mockShows
            }),

            // Mock: Simulates opening a directory and selecting a path
            openDirectoryDialog: () => Promise.resolve('/Users/mock/New_Scan_Folder'),

            // Mock: Simulates scanning the library (takes a moment)
            scanAndCacheLibrary: (rootPath) => new Promise(resolve => {
                console.log(`[MOCK IPC] Simulating scan of: ${rootPath}`);
                setTimeout(() => {
                    resolve({
                        success: true,
                        message: "Mock scan completed successfully.",
                        shows: mockShows
                    });
                }, 1500); // Simulate network/disk delay
            }),
            
            // Mock: Simulates launching an external media player
            launchExternal: (filePath) => {
                console.log(`[MOCK IPC] Simulating external launch of: ${filePath}`);
                return Promise.resolve({ success: true });
            }
        };
        console.warn('MOCK IPC BRIDGE INITIALIZED: window.api is now simulated for development in the browser.');
    }
    // --- END MOCK IPC BRIDGE ---

    // --- APP STATE AND INITIALIZATION ---
    let appState = {
      shows: [],
      selectedShowId: null,
      selectedSeasonIndex: 0,
      
      // New State for Settings
      metadataProviders: ['AniList', 'AniDB', 'TheTVDB'],
      primaryProvider: 'AniList',
      secondaryProvider: 'TheTVDB'
    };
    
    const elements = {
      sidebar: document.getElementById('sidebar'),
      detailView: document.getElementById('detail-view'),
      statusContainer: document.getElementById('status-container'),
      initialMessage: document.getElementById('initial-state-message'),
      showListTitle: document.getElementById('show-list-title'),

      // Settings elements
      settingsButton: document.getElementById('settings-button'),
      settingsModal: document.getElementById('settings-modal'),
      closeSettingsButton: document.getElementById('close-settings-button'),
      settingsScanButton: document.getElementById('settings-scan-button'),
      primaryProviderGroup: document.getElementById('primary-provider-group'),
      secondaryProviderGroup: document.getElementById('secondary-provider-group'),
    };

    // --- UTILITY FUNCTIONS ---
    
    function setStatus(message, isError = false, isLoading = false) {
        let spinner = isLoading ? '<div class="loading-spinner"></div>' : '';
        let color = isError ? 'red' : (isLoading ? 'var(--accent-color)' : 'var(--secondary-text)');
        
        elements.statusContainer.innerHTML = `
            <div class="scan-status-container flex items-center justify-center min-h-[40px]" style="color:${color};">
                ${spinner} ${message}
            </div>
        `;
        // Only disable the scan button when scanning is active
        elements.settingsScanButton.disabled = isLoading;
    }

    // UPDATED: Logic to manage Tailwind classes for fade-in/fade-out
    function toggleSettingsModal(show) {
        const modal = elements.settingsModal;
        if (show === true) {
            // 1. Make it visible (display: block)
            modal.classList.remove('hidden');
            
            // 2. Trigger the opacity and scale transition after the browser registers display: block
            setTimeout(() => {
                modal.classList.remove('opacity-0', 'scale-90');
                modal.classList.add('opacity-100', 'scale-100');
            }, 10);
            
            renderMetadataProviders(); 
        } else {
            // 1. Start the fade-out transition
            modal.classList.remove('opacity-100', 'scale-100');
            modal.classList.add('opacity-0', 'scale-90');
            
            // 2. Hide completely with display: none after the 300ms transition finishes
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300); 
        }
    }
    
    function updateProviderState(type, value) {
        if (type === 'primary') {
            appState.primaryProvider = value;
        } else if (type === 'secondary') {
            appState.secondaryProvider = value;
        }
        
        // Ensure primary and secondary providers are not the same
        if (appState.primaryProvider === appState.secondaryProvider) {
            // Find the next available provider that isn't the newly selected one
            const nextProvider = appState.metadataProviders.find(p => p !== value);
            
            if (nextProvider) {
                // If collision, force the *other* provider to the next available one
                if (type === 'primary') {
                    appState.secondaryProvider = nextProvider;
                } else if (type === 'secondary') {
                    appState.primaryProvider = nextProvider;
                }
            }
            // Re-render to reflect correction
            renderMetadataProviders(); 
        }

        console.log(`Provider updated. Primary: ${appState.primaryProvider}, Secondary: ${appState.secondaryProvider}`);
        setStatus(`Settings updated. Primary metadata provider set to ${appState.primaryProvider}.`, false, false);
    }
    
    function renderProviderOptions(type) {
        const currentSelection = (type === 'primary') ? appState.primaryProvider : appState.secondaryProvider;
        const group = (type === 'primary') ? elements.primaryProviderGroup : elements.secondaryProviderGroup;
        const name = (type === 'primary') ? 'primary-provider' : 'secondary-provider';
        
        let html = '';
        appState.metadataProviders.forEach(provider => {
            const isSelected = provider === currentSelection;

            html += `
                <label class="provider-option flex items-center gap-2 p-2 border border-border-dark rounded-md cursor-pointer transition duration-150 hover:bg-gray-800">
                    <input type="radio" 
                           name="${name}" 
                           value="${provider}" 
                           data-type="${type}" 
                           class="text-purple-500 focus:ring-purple-500"
                           ${isSelected ? 'checked' : ''}>
                    <span class="${isSelected ? 'text-purple-400 font-bold' : 'text-gray-300'}">${provider}</span>
                </label>
            `;
        });
        
        group.innerHTML = html;
        
        // Attach event listeners
        group.querySelectorAll('input[type="radio"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                updateProviderState(e.target.dataset.type, e.target.value);
            });
        });
    }

    function renderMetadataProviders() {
        renderProviderOptions('primary');
        renderProviderOptions('secondary');
    }

    function setSelectedShow(showId) {
        const show = appState.shows.find(s => s.id === showId);
        if (!show) return;

        appState.selectedShowId = showId;
        appState.selectedSeasonIndex = 0; // Default to the first season
        
        // 1. Update sidebar selection class (Tailwind classes)
        document.querySelectorAll('.show-list-item').forEach(el => {
            el.classList.remove('bg-gray-800', 'border-purple-500', 'font-bold');
            el.classList.add('hover:bg-gray-800/50');
        });
        const selectedEl = document.getElementById(`show-${showId}`);
        selectedEl.classList.add('bg-gray-800', 'border-purple-500', 'font-bold');
        selectedEl.classList.remove('hover:bg-gray-800/50');

        
        // 2. Render the detail view for the selected show
        renderDetailView(show);
    }
    
    function setSelectedSeason(seasonIndex) {
        appState.selectedSeasonIndex = parseInt(seasonIndex, 10);
        const show = appState.shows.find(s => s.id === appState.selectedShowId);
        
        if (show && show.seasons[appState.selectedSeasonIndex]) {
            renderEpisodes(show.seasons[appState.selectedSeasonIndex]);
        }
    }

    // --- RENDERING FUNCTIONS ---
    
    function renderShows() {
        if (appState.shows.length === 0) {
            elements.sidebar.innerHTML = '';
            elements.showListTitle.classList.add('hidden');
            return;
        }

        elements.initialMessage.classList.add('hidden');
        elements.showListTitle.classList.remove('hidden');

        let listHTML = elements.showListTitle.outerHTML; // Preserve the title element structure
        
        appState.shows.forEach(show => {
            // Tailwind classes applied for styling and hover effects
            listHTML += `
                <div class="show-list-item px-6 py-3 cursor-pointer text-base border-l-4 border-transparent transition duration-150 hover:bg-gray-800/50" id="show-${show.id}" data-id="${show.id}">
                    ${show.title}
                </div>
            `;
        });
        
        const listContainer = document.createElement('div');
        listContainer.innerHTML = listHTML;
        elements.sidebar.innerHTML = ''; 
        elements.sidebar.appendChild(listContainer);
        
        document.querySelectorAll('.show-list-item').forEach(el => {
            el.addEventListener('click', (e) => {
                setSelectedShow(e.currentTarget.dataset.id);
            });
        });

        const initialShowId = appState.selectedShowId || appState.shows[0].id;
        setSelectedShow(initialShowId);
    }
    
    function renderDetailView(show) {
        let detailHTML = `
            <div class="show-header mb-8">
                <h1 class="text-5xl font-extrabold text-white mb-2">${show.title}</h1>
                <p class="text-gray-400 text-lg">Template Metadata: Seasons found: ${show.seasons.length}</p>
                <p class="text-gray-500 text-sm mt-1">Root Path: ${show.rootPath}</p>
            </div>
            
            <select id="season-select" class="season-selector mb-8 p-2 bg-gray-700 border border-border-dark rounded-lg text-white appearance-none cursor-pointer">
                ${show.seasons.map((season, index) => `
                    <option value="${index}" ${index === appState.selectedSeasonIndex ? 'selected' : ''}>
                        ${season.title} (${season.episodes.length} episodes)
                    </option>
                `).join('')}
            </select>
            
            <div id="episode-list-container">
                <!-- Episodes will be rendered here -->
            </div>
        `;
        
        elements.detailView.innerHTML = detailHTML;
        
        const seasonSelect = document.getElementById('season-select');
        if (seasonSelect) {
            seasonSelect.addEventListener('change', (e) => {
                setSelectedSeason(e.target.value);
            });
        }
        
        const initialSeason = show.seasons[appState.selectedSeasonIndex];
        if (initialSeason) {
            renderEpisodes(initialSeason);
        } else {
            document.getElementById('episode-list-container').innerHTML = '<p class="text-gray-400">No episodes found in this season.</p>';
        }
    }
    
    function renderEpisodes(season) {
        const container = document.getElementById('episode-list-container');
        if (!container) return; 

        let episodeHTML = '<div class="episode-list grid gap-6">';
        
        season.episodes.forEach((episode, index) => {
            const episodeNumber = index + 1; 
            const episodeFileName = episode.fullPath.substring(episode.fullPath.lastIndexOf('/') + 1) || 
                                   episode.fullPath.substring(episode.fullPath.lastIndexOf('\\') + 1) || 
                                   episode.fullPath;

            // Tailwind classes for the episode card structure and appearance
            episodeHTML += `
                <div class="episode-card bg-card-dark rounded-xl overflow-hidden flex shadow-xl border border-border-dark transform transition duration-200 hover:scale-[1.01] hover:shadow-purple-500/30">
                    <div class="episode-template-img">S${appState.selectedSeasonIndex + 1} E${episodeNumber}</div>
                    <div class="episode-info p-4 flex flex-col justify-between flex-grow">
                        <div>
                            <div class="episode-title text-lg font-semibold text-white truncate">${episodeFileName}</div>
                            <div class="episode-description text-gray-400 text-sm mt-1">Template description: A placeholder description for the episode plot and details.</div>
                        </div>
                        <button class="action-button bg-purple-600 hover:bg-purple-500 text-white py-1 px-3 rounded-md text-sm font-medium mt-3 self-start transition duration-150 flex items-center gap-1" data-path="${episode.fullPath}">
                            <i class="fa-solid fa-play text-xs"></i> Play
                        </button>
                    </div>
                </div>
            `;
        });
        
        episodeHTML += '</div>';
        container.innerHTML = episodeHTML;
        
        document.querySelectorAll('.episode-card .action-button').forEach(button => {
            button.addEventListener('click', async (e) => {
                const filePath = e.currentTarget.dataset.path;
                const episodeFileName = filePath.substring(filePath.lastIndexOf('/') + 1) || 
                                       filePath.substring(filePath.lastIndexOf('\\') + 1) || 
                                       filePath;
                
                setStatus(`Launching ${episodeFileName}...`, false, true);
                
                const response = await window.api.launchExternal(filePath);
                
                if (response.success) {
                    setStatus('Launched successfully in external player.', false, false);
                } else {
                    setStatus(`Launch failed for ${episodeFileName}: ${response.error}`, true, false);
                }
            });
        });
    }

    // --- MAIN EVENT HANDLERS ---
    
    document.addEventListener('DOMContentLoaded', () => {
        // Event listeners for Settings Modal
        elements.settingsButton.addEventListener('click', () => toggleSettingsModal(true));
        elements.closeSettingsButton.addEventListener('click', () => toggleSettingsModal(false));
        // Allow clicking outside the modal content to close it
        elements.settingsModal.addEventListener('click', (e) => {
            if (e.target.id === 'settings-modal') {
                toggleSettingsModal(false);
            }
        });
        
        // Initial load of cached data
        window.api.fetchLibraryCache().then(response => {
            if (response.shows && response.shows.length > 0) {
                appState.shows = response.shows;
                setStatus(response.message);
                renderShows();
            } else {
                setStatus('Ready to scan. Open Settings to begin.', false, false);
            }
        });

        // Scan Button Handler (Now inside Settings)
        elements.settingsScanButton.addEventListener('click', async () => {
            console.log('SCAN BUTTON CLICKED. Starting library scan...');

            // The mock check is now done at the top of the script, but we keep this log for user clarity
            if (typeof window.api === 'undefined' || typeof window.api.openDirectoryDialog !== 'function') {
                setStatus('Error: IPC Bridge not found (Check preload script and main.js config).', true, false);
                console.error('window.api or openDirectoryDialog is UNDEFINED. Preload script is likely missing or misconfigured.');
                return;
            }

            setStatus('Opening directory selector...', false, true);
            
            try {
                // 1. Get the root path
                const rootPath = await window.api.openDirectoryDialog();

                if (!rootPath) {
                    setStatus('Scan canceled by user.', false, false);
                    return;
                }
                
                // Close settings modal immediately before starting the long scan operation
                toggleSettingsModal(false);
                setStatus(`Scanning '${rootPath}'... This may take a moment.`, false, true);
                
                // 2. Call the main process to scan and cache
                const response = await window.api.scanAndCacheLibrary(rootPath);
                
                if (response.success) {
                    appState.shows = response.shows;
                    setStatus(`Scan complete! Found ${response.shows.length} shows.`, false, false);
                    renderShows(); // RENDER THE DATA
                } else {
                    setStatus(`Scan Error: ${response.message}`, true, false);
                }
            } catch (error) {
                console.error("IPC Call Failed during Scan:", error);
                setStatus(`Fatal IPC Error: ${error.message}. See console.`, true, false);
            }
        });
    });
  </script>
</body>
</html>
